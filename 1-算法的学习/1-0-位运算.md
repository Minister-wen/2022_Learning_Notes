# 位运算/逻辑运算

##### 逻辑运算：对两个位数相同的二进制数进行操作，运算结果只针对某一位，结果不进位。

##### 因为加减乘除运算都是由位运算实现的，所以位运算在效率上比加减乘除好一些

##### 为什么使用补码呢：因为系统想让所有的加减乘除运算使用同一套逻辑运算的功能，简化运算的流程

#### AND 逻辑与 &

##### 全 1 为 1，有0则0

| x | y | Result |
| :-: | :-: | :-: |
| 1 | 1 | 1 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 0 | 0 | 0 |

#### OR 逻辑或 &

##### 全 0为 0，有1则1

|  x   |  y   | Result |
| :--: | :--: | :----: |
|  0   |  0   |   0    |
|  1   |  0   |   1    |
|  0   |  1   |   1    |
|  0   |  0   |   0    |



##### 当使用左右移动的时候，如果对一个未知的数用右移不用关系太多，因为右侧默认添0，但是左侧要注意，因为左侧填符号位的

尖的指向是移动的方向

a >> b 右移b位      右移一位相当于除以2，并保留整数     >>> 相当于不带符号右移，此使如果是负数，右移仍旧填0，带符号右移，负数补1

a<<b 左移b位     左移一位相当于乘以2，

& 可以用来判断，或者把某一位上的1取出来，|可以用来把某一位变成1



取反  

先整体取反，得出的数取反码

比如 0010    先取反    1101  负数，然后取其补码，1011

```java
int c = 5;
b = -c;
// 或者
b=~c+1;
```

##### 因此，在计算机语言中，任何一个负数不一定有一个正数和他对应，因为任何一个类型负数比正数能多表示一个。那最小的一个负数的反码呢？是他本身。比如1000，取反+1=1111+1=1000

0 



## 位运算的练习

#### 例题一：java 中打印一个int在内存中的表现形式

##### 1、从左往右打印，因此从最高位到最低位

##### 2、提取每一位上的1,&运算可以刷0

```C
public static void getbytenumber(int num){
    for(int i = 31; i >= 0 ; i--){
        System.out.print((((1<<i)&num)==0) ? "0": "1");
    }
}
```

> 这种情况，无论是正数还是负数都是可以使用的

#### 二、



## 异或（XOR）a^b

### 一、概念

##### 异或运算：每一位相同为0，不同为1

##### 异或运算本质可以理解为==无进位相加==。

```java
0 ^ N = N // 从无进位相加的角度理解，怎么加都是原来的数
N ^ N = 0
```

##### 异或运算存在交换律和结合率

```java
a ^ b = b ^ a
a ^ b ^ c = b ^ a ^ c
```

##### 按照交换律来说，通用一批数  $a_1,a_2,...,a_n$。如果他们的异或结果等于f，他们的顺序不影响最终的结果

* ##### 从无进位相加的角度来想，异或其实并不看重每一位的顺序，它看重这些数在同一位上有多少个0，多少个1.顺序不会改变每一位上1的个数。

### 二、例题

#### 1、异或的结果

```java
int a = 7;  // 0000  0000  0000  0000  0000  0000  0000  0111
int b = 13; // 0000	 0000  0000	 0000  0000  0000  0000  1101
System.out.println(a^b); //  0000  0000  0000  0000  0000  0000  0000  1010    10

```

#### 2、如何不用变量交换两个数

##### 使用条件：两个变量不能指向同一块内存空间，不然在第一步的时候，内存中的值被刷成0，因为相同数字异或刷0

##### 因此，只要在保证变量绝对不指向同一块区域的时候，才会涉及到这个用法

```C
int a = 15;
int b = 17;
a = a ^ b;// a = a ^ b;
b = a ^ b;// b = a^b^b = a;
a = a ^ b; // a = a^b^a = b;

// 在确定i一定不等于j的情况下才可以使用
arr[i] = arr[i]^arr[j];
arr[j] = arr[i]^arr[j];
arr[i] = arr[i]^arr[j];
```

#### 3、一个数组中，有一种数出现了奇数次，其他出现了偶数次，怎么找到并打印这个数

##### 关键：把所有的数都异或在一起，剩余的就是这个数字了，因为 N^N =0

```C
int arr[] = {1,1,2,3,2,7,7,9,9};
int num = 0; // 让初始值为0，因为0和任何异或都等于原来的数字
for(int item:arr){
    num = num ^ item;
}
System.out.println(num);
```

#### 4、把一个数二进制表示中==最右侧的1==提取出来,其他位值变0

##### 比如一个二进制是0000111010    要得到   000000000010

因为一个数原来最右侧1，左侧正常，右侧肯定都是0，取反，最右侧1变0，其右侧全是1，加1正好进位让这位变1.如果此使取&，则处理这一位，其他位肯定都不同，只有这位2块都是1，结果就是000000010000

##### 比如 01010   ~a = 10101   ~a+1 10110   a&（~a+1）就是 00010  ~a+1 相当于取a的相反数，于是得出下面的式子

```java
a & (~a+1) = a&(-a)
```

#### 2、一个数组中，有两种数出现了奇数次，其他出现了偶数次，怎么找到并打印这个数

##### 思考过程

##### 1. 首先，整体异或，得出两种数的异或 a^b. 它一定有一位是1，因为这两种数并不相等。

##### 2. 取二进制表示中只有这一位为1的数,比如是00000001000。整个数组被这个条件自然的分成两部分，这一位是1，和这一位不是1，二这两种数也被这个条件分开。所以整个数组可以被分成

这一位是1     a + 一堆偶数次的数

这一位不是1 b + 一堆偶数次的数

==如何判断二进制中某一位是不是1呢，用&==

```C
int arr[] = {9,1,2,3,1,2,7,8,8,9};
int err = 0;
int num1 = 0;
for(int item:arr){
    err = err^item;// 此时，它的结果为a^b
}
int num  = err&(-err); // 取二进制最右侧为1的数
for(int item:arr){
    if((item&num)!=0){
        num1 = num1^item;
    }
}
int num2 = err^num1;
System.out.println(num1);
System.out.println(num2);
```

### 5、一个数组中有一种数出现K次，其他的数都出现了M次，$M>K\geq 1$

### 找到出现K次的数，额外空间复杂度O(1),时间复杂度O(N)

* 如果是出若有其他不满足M和N的，比如x个，返回-1这种条件，x和M，K肯定不能相等，x+K也不能等于M，不然只能用哈希去做了，因为等于的条件排除不掉

##### 第一步：int长32位，则设置一个长32位的数组，初始值为32个0

##### 第二部：将每个数字的二进制中有1的个数，累加在数组中，比如一开始0000，8为1000，10为1010，则数组加完变成2010

##### 第三部：对于数组每一位，看是不是M的整数倍。注意，因为其他的数都出现了M次，只有一种K次，并且依照条件,只要某一位不是M的倍数，则这位肯定是出现一种数的二进制位

* 虽然两个循环，但是内循环不管数据量为多少，都执行31次，所以其复杂度还是O(N)

```java
public static int find(int[] arr,int K, int M){
    int arr2[] = new int[32];
    for(int item : arr){
        for(int i=0;i <= 31;i++){
            arr2[i] += (item>>i) & 1; //和0000001比，肯定是最右侧和1比，所以右移
        }
    }
    int num = 0;
    for(int i=0;i<32;i++){
        if(arr2[i]%M==K){
            num |= (1<<i);   // 或运算可以在二进制中把那一位变1
        }
    }
    return num;
}

int arr[] = {1,1,1,-1,-1,-1,-3,5,5,5,7,7,7};

```

